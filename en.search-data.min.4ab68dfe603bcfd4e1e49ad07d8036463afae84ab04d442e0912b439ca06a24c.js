'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/design-pattern-note/docs/principle/','title':"设计原则",'section':"Docs",'content':"设计原则 #  "});index.add({'id':1,'href':'/design-pattern-note/docs/creational/','title':"创建型",'section':"Docs",'content':"创建型模式 #  "});index.add({'id':2,'href':'/design-pattern-note/docs/principle/srp/','title':"单一职责原则",'section':"设计原则",'content':"单一职责原则 #  就一个类而言，应该仅有一个引起它变化的原因。\n"});index.add({'id':3,'href':'/design-pattern-note/docs/creational/abstract-factory/','title':"抽象工厂",'section':"创建型",'content':"抽象工厂模式 #  Abstract Factory Pattern\n提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类，具体的工厂负责实现具体的产品实例。\n解析\n 对产品进一步分类：抽象产品族 -\u0026gt; 抽象产品 -\u0026gt; 具体产品 每一个具体工厂，通过不同的工厂方法，可以实例化某 一类 产品族的多个具体产品  缺点\n 对于新的产品族符合开闭原则，对于新的产品不符合开闭原则，这一特性称为 开闭原则的倾斜性 。 抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，违反开闭原则。  代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':4,'href':'/design-pattern-note/docs/structural/adapter/','title':"适配器",'section':"架构型",'content':"适配器模式 #  Adapter\n适配器 Adapter 继承自 Adaptee，同时又实现了目标(Target)接口。\npublic interface Target { // 这是源类Adapteee没有的方法  public void Request(); } public class Adaptee { public void SpecificRequest() { } } // 适配器Adapter继承自Adaptee，同时又实现了目标(Target)接口。 public class Adapter extends Adaptee implements Target { // 目标接口要求调用Request()这个方法名，但源类Adaptee没有方法Request()  // 因此适配器补充上这个方法名  // 但实际上Request()只是调用源类Adaptee的SpecificRequest()方法的内容  // 所以适配器只是将SpecificRequest()方法作了一层封装，封装成Target可以调用的Request()而已  @Override public void Request() { this.SpecificRequest(); } } public class AdapterPattern { public static void main(String[] args){ Target mAdapter = new Adapter()； mAdapter.Request(); } } 代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':5,'href':'/design-pattern-note/docs/behavioral/command/','title':"命令",'section':"行为型",'content':"命令模式 #  Command Pattern\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':6,'href':'/design-pattern-note/docs/other/concurrency/','title':"并行模式",'section':"其他模式",'content':"并行模式 #  "});index.add({'id':7,'href':'/design-pattern-note/docs/principle/ocp/','title':"开闭原则",'section':"设计原则",'content':"开闭原则 #  程序中的对象应该对扩展是开放的，对修改是封闭的。\n当一个类实现了一个功能的时候，如果想要改变这个功能不是去修改代码，而是通过扩展的方式去实现。 实现该类提供的接口方法，然后注入到该类中，通过这种方法去实现功能的改变。\n"});index.add({'id':8,'href':'/design-pattern-note/docs/creational/builder/','title':"构造器",'section':"创建型",'content':"构造器模式 #  Builder\n 抽象 Builder 规定要有哪些方法（用来创建产品） 具体 Builder 的方法可以实现不一样的内容，这些方法按顺序完成后，可以创建出来特定的产品 Director 规定创建产品的步骤；接收具体的 Builder 对象作为参数，按步骤调用 Builder 对象的各个方法，最后获取到创建的产品  解析\n 创建产品的步骤是一致的，所有步骤完成后，就创建出产品 不同 Builder 的同一步可以做不同的事情，最后创建出不同的产品  缺点\n 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大  代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':9,'href':'/design-pattern-note/docs/structural/','title':"架构型",'section':"Docs",'content':"架构型模式 #  "});index.add({'id':10,'href':'/design-pattern-note/docs/structural/bridge/','title':"桥接",'section':"架构型",'content':"桥接模式 #  Bridge\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':11,'href':'/design-pattern-note/docs/creational/factory-method/','title':"工厂方法",'section':"创建型",'content':"工厂方法模式 #  Factory Method\n又称工厂模式、多态工厂模式和虚拟构造器模式，\n通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。\n 每个产品的实例化，分别有一个具体工厂负责 符合开闭原则：对扩展开放，对修改关闭 添加一种产品，就添加一种实现该产品的工厂  缺点\n 每个工厂只能创建一类产品  代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':12,'href':'/design-pattern-note/docs/structural/composite/','title':"组合",'section':"架构型",'content':"组合模式 #  Composite Pattern\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':13,'href':'/design-pattern-note/docs/behavioral/interpreter/','title':"翻译器",'section':"行为型",'content':"翻译器模式 #  Interpreter Pattern\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':14,'href':'/design-pattern-note/docs/behavioral/','title':"行为型",'section':"Docs",'content':"行为型模式 #  "});index.add({'id':15,'href':'/design-pattern-note/docs/principle/lsp/','title':"里氏替换原则",'section':"设计原则",'content':"里氏替换原则 #   所有引用基类的地方必须能透明的使用其子类对象。 只要父类能出现的地方子类就可以出现，替换为子类也不会产生任何的错误。 开闭原则一般可以通过里氏替换实现对扩展开放，对修改关闭的效果。  "});index.add({'id':16,'href':'/design-pattern-note/docs/principle/dip/','title':"依赖倒置原则",'section':"设计原则",'content':"依赖倒置原则 #   模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的。 即依赖抽象，而不依赖具体的实现。  "});index.add({'id':17,'href':'/design-pattern-note/docs/creational/prototype/','title':"原型",'section':"创建型",'content':"原型模式 #  Prototype\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':18,'href':'/design-pattern-note/docs/structural/decorator/','title':"装饰",'section':"架构型",'content':"装饰模式 #  Decorator\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':19,'href':'/design-pattern-note/docs/behavioral/iterator/','title':"迭代器",'section':"行为型",'content':"迭代器模式 #  Iterator Pattern\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':20,'href':'/design-pattern-note/docs/behavioral/mediator/','title':"中介者",'section':"行为型",'content':"中介者模式 #  Mediator Pattern\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':21,'href':'/design-pattern-note/docs/creational/singleton/','title':"单例",'section':"创建型",'content':"单例模式 #  Singleton\n实现方法 #   初始化时即创建单例  饿汉式 枚举类型   按需，延迟创建单例  懒汉式  基础实现 同步锁 双重检验锁   静态内部类实现    饿汉式（线程安全） #   JVM 在类的初始化阶段 (即 在 Class 被加载后、被线程使用前)，会执行类的初始化 在执行类的初始化期间，JVM 会去获取一个锁，这个锁可以同步多个线程对同一个类的初始化  class Singleton { // 1. 加载该类时，单例就会自动被创建  private static Singleton ourInstance = new Singleton(); // 2. 构造函数设置为 私有权限，禁止他人创建实例  private Singleton() { } // 3. 通过调用静态方法获得创建的单例  public static Singleton newInstance() { return ourInstance; } } 应用场景\n 单例对象要求初始化速度快，占用内存小  枚举类（线程安全） #   这是最简洁，最易用的单例实现方式   单元素的枚举类型已经成为实现 Singleton 的最佳方法 - 《Effective Java》\n public enum Singleton { // 定义 1 个枚举的元素，即为单例类的1个实例  INSTANCE; // 隐藏了 1 个空的、私有的 构造方法  // private Singleton () {} } // 获取单例的方式： Singleton singleton = Singleton.INSTANCE; 懒汉式 基础实现（线程不安全） #  class Singleton { // 1. 类加载时，先不自动创建单例，将单例的引用先赋值为 Null  private static Singleton ourInstance = null; // 2. 构造函数 设置为 私有权限  // 禁止他人创建实例  private Singleton() { } // 3. 需要时才手动调用 newInstance（） 创建 单例  public static Singleton newInstance() { // 先判断单例是否为空，以避免重复创建  if (ourInstance == null) { ourInstance = new Singleton(); } return ourInstance; } } 懒汉式 同步锁（线程安全） #  // 写法1 class Singleton { // 1. 类加载时，先不自动创建单例  // 即，将单例的引用先赋值为 Null  private static Singleton ourInstance = null； // 2. 构造函数 设置为 私有权限  // 原因：禁止他人创建实例  private Singleton() { } // 3. 加入同步锁  public static synchronized Singleton getInstance() { // 先判断单例是否为空，以避免重复创建  if (ourInstance == null) ourInstance = new Singleton(); return ourInstance; } } // 写法2 // 该写法的作用与上述写法作用相同，只是写法有所区别 class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { // 加入同步锁  synchronized (Singleton.class) { if (instance == null) instance = new Singleton(); } return instance; } } 缺点\n 每次访问都要进行线程同步（即 调用 synchronized 锁)，造成过多的同步开销（加锁 = 耗时、耗能） 实际上只需在第 1 次调用该方法时才需要同步，一旦单例创建成功后，就没必要进行同步  懒汉式 双重检验锁（线程安全） #  class Singleton { private static Singleton ourInstance = null； private Singleton() { } public static Singleton newInstance() { // 加入双重校验锁  // 校验锁1：第1个if  if (ourInstance == null) { // ①  synchronized (Singleton.class) { // ②  // 校验锁2：第2个 if  if (ourInstance == null) { ourInstance = new Singleton(); } } } return ourInstance; } } // 说明 // 校验锁1：第1个if // 作用：若单例已创建，则直接返回已创建的单例，无需再执行加锁操作 // 即直接跳到执行 return ourInstance  // 校验锁2：第2个 if // 作用：防止多次创建单例问题 // 原理 // 1. 线程A调用newInstance()，当运行到②位置时，此时线程B也调用了newInstance() // 2. 因线程A并没有执行instance = new Singleton();，此时instance仍为空，因此线程B能突破第1层 if // 判断，运行到①位置等待synchronized中的A线程执行完毕 // 3. 当线程A释放同步锁时，单例已创建，即instance已非空 // 4. 此时线程B 从①开始执行到位置②。此时第2层 if 判断 = 为空（单例已创建），因此也不会创建多余的实例 缺点\n 实现复杂（多种判断），易出错  静态内部类（线程安全） #  class Singleton { // 1. 创建静态内部类  private static class Singleton2 { // 在静态内部类里创建单例  private static Singleton ourInstance = new Singleton()； } // 私有构造函数  private Singleton() { } // 延迟加载、按需创建  public static Singleton newInstance() { return Singleton2.ourInstance; } } 调用过程说明：\n 外部调用类的 newInstance() 自动调用 Singleton2.ourInstance  此时单例类 Singleton2 得到初始化 而该类在装载 \u0026amp; 被初始化时，会初始化它的静态域，从而创建单例； 由于是静态域，因此只会 JVM 只会加载 1 遍，Java 虚拟机保证了线程安全性   最终只创建 1 个单例  缺点\n 单例类的职责过重，里面的代码可能会过于复杂，在一定程度上违背了 \u0026ldquo;单一职责原则\u0026rdquo; 如果实例化的对象长时间不被利用，会被系统认为是垃圾而被回收，这将导致对象状态的丢失  代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':22,'href':'/design-pattern-note/docs/structural/facade/','title':"外观",'section':"架构型",'content':"外观模式 #  Facade\n 适配器是将接口转换为不同接口 外观模式是提供一个统一的接口来简化接口  public class Facade Pattern { public static void main(String[] args) { //实例化电器类  SubSystemA_Light light = new SubSystemA_Light(); SubSystemB_Television television = new SubSystemB_Television(); SubSystemC_Aircondition aircondition = new SubSystemC_Aircondition(); //传参  Facade facade = new Facade(light,television,aircondition); //客户端直接与外观对象进行交互  facade.on; System.out.prinln(\u0026#34;可以看电视了\u0026#34;)； facade.off; System.out.prinln(\u0026#34;可以睡觉了\u0026#34;)； } } 代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':23,'href':'/design-pattern-note/docs/principle/isp/','title':"接口隔离原则",'section':"设计原则",'content':"接口隔离原则 #   客户端不应该依赖它不需要的接口。 目的是解开系统的耦合，从而容易重构更改。  "});index.add({'id':24,'href':'/design-pattern-note/docs/other/simple-factory/','title':"简单工厂",'section':"其他模式",'content':"简单工厂模式 #  Simple Factory Pattern，又称为静态工厂方法 (Static Factory Method) 模式\n通过传入参数获取到对象，不关心创建对象的细节。\n// create 是静态方法，直接用类调用（不需要实例化） object1 = Factory.create(1); object2 = Factory.create(2); 优点\n 将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦； 把初始化实例时的工作放到工厂里进行，使代码更容易维护。 更符合面向对象的原则 \u0026amp; 面向接口编程，而不是面向实现编程。  缺点\n 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响； 违背 “开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。 静态方法可以被继承  应用场景\n 客户如果只知道传入工厂类的参数，对于如何创建对象的逻辑不关心时； 当工厂类负责创建的对象（具体产品）比较少时。  代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':25,'href':'/design-pattern-note/docs/structural/flyweight/','title':"享元",'section':"架构型",'content':"享元模式 #  Flyweight\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':26,'href':'/design-pattern-note/docs/behavioral/memento/','title':"回忆",'section':"行为型",'content':"回忆模式 #  Memento Pattern\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':27,'href':'/design-pattern-note/docs/behavioral/chain-of-responsibility/','title':"职责链",'section':"行为型",'content':"职责链模式 #  Chain-of-responsibility Pattern\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':28,'href':'/design-pattern-note/docs/principle/lod/','title':"迪米特原则",'section':"设计原则",'content':"迪米特原则 #   一个对象应该对其他对象有最少的了解 一个类应该对自己需要耦合或调用的类知道的越少越好，类的内部如何实现与调用者或依赖者没关系。  "});index.add({'id':29,'href':'/design-pattern-note/docs/structural/proxy/','title':"代理",'section':"架构型",'content':"代理模式 #  Proxy\npublic interface Subject { public void buyMac(); } public class RealSubject implement Subject { @Override public void buyMac() { System.out.println(\u0026#34;买一台Mac\u0026#34;); } } public class Proxy implements Subject { @Override public void buyMac { //引用并创建真实对象实例，即\u0026#34;我\u0026#34;  RealSubject realSubject = new RealSubject(); //调用真实对象的方法，进行代理购买Mac  realSubject.buyMac(); //代理对象额外做的操作  this.WrapMac(); } public void WrapMac() { System.out.println(\u0026#34;用盒子包装好Mac\u0026#34;); } } public class ProxyPattern { public static void main(String[] args) { Subject proxy = new Proxy(); proxy.buyMac(); } } 代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':30,'href':'/design-pattern-note/docs/behavioral/observer/','title':"观察者",'section':"行为型",'content':"观察者模式 #  Observer Pattern\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':31,'href':'/design-pattern-note/docs/behavioral/state/','title':"状态机",'section':"行为型",'content':"状态机模式 #  State Pattern\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':32,'href':'/design-pattern-note/docs/other/','title':"其他模式",'section':"Docs",'content':"其他模式 #  "});index.add({'id':33,'href':'/design-pattern-note/docs/behavioral/strategy/','title':"策略",'section':"行为型",'content':"策略模式 #  Strategy Pattern\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':34,'href':'/design-pattern-note/docs/behavioral/template-method/','title':"模板方法",'section':"行为型",'content':"模板方法模式 #  Template Method Pattern\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});index.add({'id':35,'href':'/design-pattern-note/docs/behavioral/visitor/','title':"参观者",'section':"行为型",'content':"参观者模式 #  Visitor Pattern\n代码示例 #  C C\u0026#43;\u0026#43; C# Go Java JavaScript Kotlin PHP Python2 Python3 Ruby Rust Scala Swift TypeScript  "});})();